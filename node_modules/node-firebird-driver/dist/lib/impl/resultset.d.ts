import { AbstractStatement } from './statement';
import { AbstractTransaction } from './transaction';
import { FetchOptions, ResultSet } from '..';
/** AbstractResultSet implementation. */
export declare abstract class AbstractResultSet implements ResultSet {
    statement?: AbstractStatement | undefined;
    transaction?: AbstractTransaction | undefined;
    finished: boolean;
    diposeStatementOnClose: boolean;
    /** Default result set's fetch options. */
    defaultFetchOptions: FetchOptions;
    protected constructor(statement?: AbstractStatement | undefined, transaction?: AbstractTransaction | undefined);
    /** Closes this result set. */
    close(): Promise<void>;
    /**
     * Fetchs data from this result set as [col1, col2, ..., colN][].
     *
     * If an exception is found after fetching a row but before reaching options.fetchSize, its throw is delayed for the next fetch call.
     *
     * If result set has no more rows, returns an empty array.
     */
    fetch(options?: FetchOptions): Promise<any[][]>;
    /**
     * Fetchs data from this result set as T[].
     * Where <T> represents your object interface.
     *
     * If an exception is found after fetching a row but before reaching options.fetchSize, its throw is delayed for the next fetch call.
     *
     * If result set has no more rows, returns an empty array.
     */
    fetchAsObject<T extends object>(options?: FetchOptions): Promise<T[]>;
    get isValid(): boolean;
    private check;
    protected abstract internalClose(): Promise<void>;
    protected abstract internalFetch(options?: FetchOptions): Promise<{
        finished: boolean;
        rows: any[][];
    }>;
}
