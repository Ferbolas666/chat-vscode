"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractAttachment = void 0;
/** AbstractAttachment implementation. */
class AbstractAttachment {
    constructor(client) {
        this.client = client;
        this.events = new Set();
        this.statements = new Set();
        this.transactions = new Set();
    }
    /** Disconnects this attachment. */
    async disconnect() {
        this.check();
        await this.preDispose();
        await this.internalDisconnect();
        await this.postDispose();
    }
    /** Drops the database and release this attachment. */
    async dropDatabase() {
        this.check();
        await this.preDispose();
        await this.internalDropDatabase();
        await this.postDispose();
    }
    /** Enable/disable cancellation of operations in this attachment. */
    async enableCancellation(enable) {
        this.check();
        await this.internalEnableCancellation(enable);
    }
    /** Cancel a running operation in this attachment. */
    async cancelOperation(forcibleAbort) {
        this.check();
        await this.internalCancelOperation(forcibleAbort ?? false);
    }
    /** Executes a statement that uses the SET TRANSACTION command. Returns the new transaction. */
    async executeTransaction(transaction, sqlStmt, options) {
        this.check();
        const statement = await this.prepare(transaction, sqlStmt, options && options.prepareOptions);
        try {
            const newTransaction = await statement.executeTransaction(transaction);
            this.transactions.add(newTransaction);
            return newTransaction;
        }
        finally {
            await statement.dispose();
        }
    }
    /** Executes a statement that has no result set. */
    async execute(transaction, sqlStmt, parameters, options) {
        this.check();
        const statement = await this.prepare(transaction, sqlStmt, options && options.prepareOptions);
        try {
            return await statement.execute(transaction, parameters, options && options.executeOptions);
        }
        finally {
            await statement.dispose();
        }
    }
    /** Executes a statement that returns a single record. */
    async executeSingleton(transaction, sqlStmt, parameters, options) {
        this.check();
        const statement = await this.prepare(transaction, sqlStmt, options && options.prepareOptions);
        try {
            return await statement.executeSingleton(transaction, parameters, options && options.executeOptions);
        }
        finally {
            await statement.dispose();
        }
    }
    /** Executes a statement that returns a single record in object form. */
    async executeSingletonAsObject(transaction, sqlStmt, parameters, options) {
        this.check();
        const statement = await this.prepare(transaction, sqlStmt, options && options.prepareOptions);
        try {
            return await statement.executeSingletonAsObject(transaction, parameters, options && options.executeOptions);
        }
        finally {
            await statement.dispose();
        }
    }
    /** Executes a statement that returns a single record. */
    async executeReturning(transaction, sqlStmt, parameters, options) {
        return await this.executeSingleton(transaction, sqlStmt, parameters, options);
    }
    /** Executes a statement that returns a single record in object form. */
    async executeReturningAsObject(transaction, sqlStmt, parameters, options) {
        return await this.executeSingletonAsObject(transaction, sqlStmt, parameters, options);
    }
    /** Executes a statement that has result set. */
    async executeQuery(transaction, sqlStmt, parameters, options) {
        this.check();
        const statement = await this.prepare(transaction, sqlStmt, options && options.prepareOptions);
        try {
            const resultSet = await statement.executeQuery(transaction, parameters, options && options.executeOptions);
            resultSet.diposeStatementOnClose = true;
            return resultSet;
        }
        catch (e) {
            await statement.dispose();
            throw e;
        }
    }
    async queueEvents(names, callBack) {
        this.check();
        const trimmedNames = names.map(name => {
            const trimmedName = name.trimRight();
            if (Buffer.from(trimmedName).byteLength > 255)
                throw new Error(`Invalid event name: ${name}.`);
            return trimmedName;
        });
        const events = await this.internalQueueEvents(trimmedNames, callBack);
        this.events.add(events);
        return events;
    }
    async createBlob(transaction, options) {
        return await this.internalCreateBlob(transaction, options);
    }
    async openBlob(transaction, blob) {
        return await this.internalOpenBlob(transaction, blob);
    }
    /** Starts a new transaction. */
    async startTransaction(options) {
        this.check();
        const transaction = await this.internalStartTransaction(options || this.defaultTransactionOptions || this.client.defaultTransactionOptions);
        this.transactions.add(transaction);
        return transaction;
    }
    /** Prepares a query. */
    async prepare(transaction, sqlStmt, options) {
        this.check();
        const statement = await this.internalPrepare(transaction, sqlStmt, options || this.defaultPrepareOptions || this.client.defaultPrepareOptions);
        this.statements.add(statement);
        return statement;
    }
    get isValid() {
        return !!this.client;
    }
    check() {
        if (!this.isValid)
            throw new Error('Attachment is already disconnected.');
    }
    async preDispose() {
        try {
            await Promise.all(Array.from(this.events).map(events => events.cancel()));
            await Promise.all(Array.from(this.statements).map(statement => statement.dispose()));
            await Promise.all(Array.from(this.transactions).map(transaction => transaction.rollback()));
        }
        finally {
            this.events.clear();
            this.statements.clear();
            this.transactions.clear();
        }
    }
    async postDispose() {
        this.client.attachments.delete(this);
        this.client = undefined;
    }
}
exports.AbstractAttachment = AbstractAttachment;
//# sourceMappingURL=attachment.js.map