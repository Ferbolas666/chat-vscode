"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractStatement = void 0;
/** AbstractStatement implementation. */
class AbstractStatement {
    constructor(attachment) {
        this.attachment = attachment;
    }
    /** Disposes this statement's resources. */
    async dispose() {
        this.check();
        if (this.resultSet)
            await this.resultSet.close();
        await this.internalDispose();
        this.attachment.statements.delete(this);
        this.attachment = undefined;
    }
    /** Executes a prepared statement that uses the SET TRANSACTION command. Returns the new transaction. */
    async executeTransaction(transaction) {
        this.check();
        //// TODO: check opened resultSet.
        return await this.internalExecuteTransaction(transaction);
    }
    /** Executes a prepared statement that has no result set. */
    async execute(transaction, parameters, options) {
        this.check();
        //// TODO: check opened resultSet.
        await this.internalExecute(transaction, parameters, options || this.attachment.defaultExecuteOptions || this.attachment.client.defaultExecuteOptions);
    }
    /** Executes a statement that returns a single record as [col1, col2, ..., colN]. */
    async executeSingleton(transaction, parameters, options) {
        this.check();
        //// TODO: check opened resultSet.
        return await this.internalExecute(transaction, parameters, options || this.attachment.defaultExecuteOptions || this.attachment.client.defaultExecuteOptions);
    }
    /** Executes a statement that returns a single record as an object. */
    async executeSingletonAsObject(transaction, parameters, options) {
        this.check();
        const row = await this.executeSingleton(transaction, parameters, options);
        const cols = (await this?.columnLabels) || [];
        const obj = {};
        // Loop on row column value.
        row.forEach((v, idx) => {
            const col = cols[idx];
            obj[col] = v;
        });
        return obj;
    }
    /** Executes a statement that returns a single record as [col1, col2, ..., colN]. */
    async executeReturning(transaction, parameters, options) {
        return await this.executeSingleton(transaction, parameters, options);
    }
    /** Executes a statement that returns a single record as an object. */
    async executeReturningAsObject(transaction, parameters, options) {
        return await this.executeSingletonAsObject(transaction, parameters, options);
    }
    /** Executes a prepared statement that has result set. */
    async executeQuery(transaction, parameters, options) {
        this.check();
        //// TODO: check opened resultSet.
        const resultSet = await this.internalExecuteQuery(transaction, parameters, options || this.attachment.defaultExecuteQueryOptions || this.attachment.client.defaultExecuteQueryOptions);
        this.resultSet = resultSet;
        return resultSet;
    }
    get isValid() {
        return !!this.attachment;
    }
    check() {
        if (!this.isValid)
            throw new Error('Statement is already disposed.');
    }
}
exports.AbstractStatement = AbstractStatement;
//# sourceMappingURL=statement.js.map