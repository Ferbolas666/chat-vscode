import { AbstractBlobStream } from './blob';
import { AbstractClient } from './client';
import { AbstractResultSet } from './resultset';
import { AbstractStatement } from './statement';
import { AbstractTransaction } from './transaction';
import { AbstractEvents } from './events';
import { Attachment, Blob, CreateBlobOptions, ExecuteOptions, ExecuteQueryOptions, Events, FetchOptions, PrepareOptions, TransactionOptions } from '..';
/** AbstractAttachment implementation. */
export declare abstract class AbstractAttachment implements Attachment {
    client?: AbstractClient | undefined;
    events: Set<Events>;
    statements: Set<AbstractStatement>;
    transactions: Set<AbstractTransaction>;
    /** Default transaction options. */
    defaultTransactionOptions: TransactionOptions;
    /** Default query's prepare options. */
    defaultPrepareOptions: PrepareOptions;
    /** Default query's execute options. */
    defaultExecuteOptions: ExecuteOptions;
    /** Default query's executeQuery options. */
    defaultExecuteQueryOptions: ExecuteQueryOptions;
    /** Default result set's fetch options. */
    defaultFetchOptions: FetchOptions;
    protected constructor(client?: AbstractClient | undefined);
    /** Disconnects this attachment. */
    disconnect(): Promise<void>;
    /** Drops the database and release this attachment. */
    dropDatabase(): Promise<void>;
    /** Enable/disable cancellation of operations in this attachment. */
    enableCancellation(enable: boolean): Promise<void>;
    /** Cancel a running operation in this attachment. */
    cancelOperation(forcibleAbort?: boolean): Promise<void>;
    /** Executes a statement that uses the SET TRANSACTION command. Returns the new transaction. */
    executeTransaction(transaction: AbstractTransaction, sqlStmt: string, options?: {
        prepareOptions?: PrepareOptions;
    }): Promise<AbstractTransaction>;
    /** Executes a statement that has no result set. */
    execute(transaction: AbstractTransaction, sqlStmt: string, parameters?: any[], options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteOptions;
    }): Promise<void>;
    /** Executes a statement that returns a single record. */
    executeSingleton(transaction: AbstractTransaction, sqlStmt: string, parameters?: Array<any>, options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteOptions;
    }): Promise<Array<any>>;
    /** Executes a statement that returns a single record in object form. */
    executeSingletonAsObject<T extends object>(transaction: AbstractTransaction, sqlStmt: string, parameters?: any[], options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteOptions;
    }): Promise<T>;
    /** Executes a statement that returns a single record. */
    executeReturning(transaction: AbstractTransaction, sqlStmt: string, parameters?: Array<any>, options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteOptions;
    }): Promise<Array<any>>;
    /** Executes a statement that returns a single record in object form. */
    executeReturningAsObject<T extends object>(transaction: AbstractTransaction, sqlStmt: string, parameters?: any[], options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteOptions;
    }): Promise<T>;
    /** Executes a statement that has result set. */
    executeQuery(transaction: AbstractTransaction, sqlStmt: string, parameters?: any[], options?: {
        prepareOptions?: PrepareOptions;
        executeOptions?: ExecuteQueryOptions;
    }): Promise<AbstractResultSet>;
    queueEvents(names: string[], callBack: (counters: [string, number][]) => Promise<void>): Promise<Events>;
    createBlob(transaction: AbstractTransaction, options?: CreateBlobOptions): Promise<AbstractBlobStream>;
    openBlob(transaction: AbstractTransaction, blob: Blob): Promise<AbstractBlobStream>;
    /** Starts a new transaction. */
    startTransaction(options?: TransactionOptions): Promise<AbstractTransaction>;
    /** Prepares a query. */
    prepare(transaction: AbstractTransaction, sqlStmt: string, options?: PrepareOptions): Promise<AbstractStatement>;
    get isValid(): boolean;
    private check;
    private preDispose;
    private postDispose;
    protected abstract internalDisconnect(): Promise<void>;
    protected abstract internalDropDatabase(): Promise<void>;
    protected abstract internalEnableCancellation(enable: boolean): Promise<void>;
    protected abstract internalCancelOperation(forcibleAbort: boolean): Promise<void>;
    protected abstract internalCreateBlob(transaction: AbstractTransaction, options?: CreateBlobOptions): Promise<AbstractBlobStream>;
    protected abstract internalOpenBlob(transaction: AbstractTransaction, blob: Blob): Promise<AbstractBlobStream>;
    protected abstract internalPrepare(transaction: AbstractTransaction, sqlStmt: string, options?: PrepareOptions): Promise<AbstractStatement>;
    protected abstract internalStartTransaction(options?: TransactionOptions): Promise<AbstractTransaction>;
    protected abstract internalQueueEvents(names: string[], callBack: (counters: [string, number][]) => Promise<void>): Promise<AbstractEvents>;
}
